# 第8章 算法

- 定义算法
- 定义三种结构（顺序、选择和循环）
- 描述UML图和当表示算法时它们是如何使用的
- 描述伪代码和当表示算法时它们是如何使用的
- 列出基本算法和它们的应用
- 描述排序的概念，理解三种原始排序算法的机制
- 描述搜索的概念，理解两种常见搜索算法的机制
- 定义子算法和它们与算法的关系
- 区分迭代和递归算法

## 算法（简单定义）

### 概念

算法的概念

- <font color='red'>非正式定义：</font>是一种<font color='red'>逐步</font>解决问题或完成任务的<font color='red'>方法</font>，按照这种定义，算法完全独立于计算机系统
- 计算机算法接收一组输入数据，同时产生一组输出数据

![image-20221108163110841](算法.assets/image-20221108163110841.png)

### 示例

求5个正整数的最大值

![image-20221113191428792](算法.assets/image-20221113191428792.png)

定义动作

![image-20221113191501845](算法.assets/image-20221113191501845.png)

细化

![image-20221113191529308](算法.assets/image-20221113191529308.png)

泛化

![image-20221113191559250](算法.assets/image-20221113191559250.png)

### 三种结构

计算机专家为结构化程序或算法定义了三种结构，这种想法认为程序必定是由<font color='red'>顺序</font>、<font color='red'>判断</font>（选择）和<font color='red'>循环</font>组成，已经证实其它结构是不必要的

![image-20221113191812741](算法.assets/image-20221113191812741.png)

### 算法的表示

- 使用<font color='red'>UML和伪代码</font>来表示算法

- UML（统一建模语言）是算法的图形表示法，使用图的形式掩盖了算法的所有细节，只显示算法从开始到结束的整个流程

    ![image-20221113192049331](算法.assets/image-20221113192049331.png)

- 伪代码是算法的一种类似英语的表示法，到现在还没有伪代码的标准

![image-20221113192100122](算法.assets/image-20221113192100122.png)

例 8.1：用伪代码写出求两个整数之和的算法

解	这个简单的问题只要使用顺序结构就可以解决。注意，同时还给该算法命名，定义算法的输入，并在结尾用一条返回指令来返回和。

​																	算法8.1	计算两个整数之和	

> ​	算法：SumOfTwo(first, second)
>
> ​	目的：求两个整数之和
>
> ​	前提：给定两个整数（first和second）
>
> ​	后续：无
>
> ​	返回：和的值
>

```
{
	sum <- first + second
	return sum
}
```

例 8.2：编写可以把一组不同的成绩分成及格或不及格的算法

解	这个问题如果仅用顺序结构将无法完成，另外还需要判断结构。计算机给出0~100之间的一个数，如果这个数大于或等于70则返回“及格”（pass），如果小于70则返回“不及格”（nopass）。

​																	算法8.2	及格/不及格分级

> ​	算法：Pass/Nopass(score)
>
> ​	目的：给定分数，创建及格/不及格等级
>
> ​	前提：给定要被改成等级的分数
>
> ​	后续：无
>
> ​	返回：等级
>

```
{
	if(score ≥ 70)	grade <- "pass"
	else			grade <- "nopass"
	return grade
}
```

例 8.3：编写将数字型成绩（整数）变为字母等级成绩的算法。

解	这个问题需要多个判断。算法8.3中的伪代码显示的是一种解决方法（并不是最好的方法，但却是最容易理解的方法）。同样，计算机给出0~100之间的任意一个数，算法必须把它划分到正确的字母等级中去（A、B、C、D、或F）。

​																	算法8.3	赋予字母等级成绩

> 算法：LetterGrade(score)
>
> 目的：给定分数，找到相应的字母等级
>
> 前提：给定数字分数
>
> 后续：无
>
> 返回：字母等级

```
{
	if (100 ≥ score ≥ 90)	grade <- 'A'
	if (89 ≥ score ≥ 80)	grade <- 'B'
	if (79 ≥ score ≥ 70)	grade <- 'C'
	if (69 ≥ score ≥ 60)	grade <- 'D'
	if (59 ≥ score ≥ 0)	grade <- 'F'
}
```

例 8.4： 编写从一组整数中求最大数的算法，该组整数的数目事先并不知道。

解	使用图8-5中介绍的概念编写出解决该问题的算法（见算法8.4）

​																	算法8.4	求一组整数中的最大值

> 算法：FindLargest(list)
>
> 目的：求一组整数中的最大值
>
> 前提：给定一组整数
>
> 后续：无
>
> 返回：最大整数

```
{
	largest <- -∞
	while (more integers to check)
	{
		current <- nextinteger
		if (current > largest)	largest <- current
	}
	return largest
}
```

例 8.5：编写从一组整数前1000个整数中求最小值的算法。

解	这里需要用一个计数器来计数。把这个计数器初始化为1，每循环一次就对它加1。当计数器大于1000时，退出循环（参见算法8.5）。注意，列表中有超过1000个整数，但是我们需要求前1000个整数中的最小值。

​																	算法8.5	求前1000个整数中的最小整数

> 算法：FindSmallest(list)
>
> 目的：求前1000个整数中的最小整数，并返回
>
> 前提：给定一组超过1000个整数
>
> 后续：无
>
> 返回：最小整数

```java
{
	smallest <- +∞
	counter <- 1
	while (counter ≤ 1000)
	{
		current <- nextinteger
		if (current < smallest)
		smallest <- current
		counter <- counter + 1
	}
	return smallest
}
```

## 算法

- 更正式的定义：算法是一组<font color='red'>明确</font>步骤的<font color='red'>有序集合</font>，它产生结果并在<font color='red'>有限的时间</font>内终止
- 算法必须是一组<font color='red'>定义良好（最优算法）</font>且有序的指令集合

### 基本算法

- 求和：对一组数据求和
    - 将和（sum）初始化
    - 循环，在每次迭代中将一个新数加到sum上
    - 退出循环后返回结果

![image-20221114193055649](算法.assets/image-20221114193055649.png)

- 乘积：对一组数据的乘积
    - 将乘积（product）初始化
    - 循环，在每次迭代中将一个新的数与product相乘
    - 退出循环后返回结果

![image-20221114193904643](算法.assets/image-20221114193904643.png)

- 最大和最小：求一组数据的最大和最小值

- 排序：根据一组数据的值对它们进行排序

    - 选择排序
    - 冒泡排序
    - 插入排序

    > 这三种排序方法是当今计算机科学中使用的快速排序的基础

#### 选择排序

数字列表可分成<font color='red'>两个子列表</font>（已排序和未排序），它们通过假想的一堵墙分开。求未排序子列表中<font color='red'>最小</font>的元素并把它和未排序子列表中的第一个元素<font color='red'>交换</font>，经过每次<font color='red'>选择和交换</font>，两个子列表中假想的墙向前移动一个元素，这样每一次已排序列表将增加一个元素而未排序列表中减少一个元素，每次把一个元素从未排序列表移到已排序列表就完成了一轮排序。

![image-20221117212101834](算法.assets/image-20221117212101834.png)

- 选择排序示例

![image-20221117212129550](算法.assets/image-20221117212129550.png)

- 选择排序算法——UML图解

![image-20221117212205713](算法.assets/image-20221117212205713.png)

#### 冒泡排序

数字列表被分为<font color='red'>两个子列表</font>：<font color='red'>已排序和未排序</font>。在未排序子列表中，最小的元素通过<font color='red'>冒泡</font>的方法选出并移动到已排序的字列表中，当把最小的元素移到已排序列表之后，墙向前移动一个元素，使得已排序元素的个数加1，而未排序元素的个数减少1个。每次元素从未排序子列表中移到已排序子列表中，最终完成排序

![image-20221209134933473](算法.assets/image-20221209134933473.png)

- 冒泡排序示例

![image-20221209135037400](算法.assets/image-20221209135037400.png)

- 冒泡排序算法：

```java
private static void bubbleSort(int[] arr) {
  for (int i = 0; i < arr.length; i++) {
    for (int j = arr.length -1; j > i; j--) {
      if (arr[j] < arr[j - 1]) {
      int tem = arr[j];
      arr[j] = arr[j-1];
      arr[j - 1] = tem;
      }
  	}
  }
}
```

- UML图（略）

#### 插入排序

排序列表被分为<font color='red'>已排序</font>和<font color='red'>未排序</font>两个列表。在每轮中，把未排序子列表中的第一个元素转移到已排序的子列表中，并插入到<font color='red'>合适的位置</font>

![image-20221209141135144](算法.assets/image-20221209141135144.png)

- 插入排序示例

![image-20221209142213953](算法.assets/image-20221209142213953.png)

- 插入排序算法

```java
   private static void insertSort(int[] arr) {
        // 1, 5, 6, 4, 2, 3
        // 从数组的第二个元素开始循环将数组中的元素插入
        for (int i = 1; i < arr.length; i++) {
            int j = i - 1;
            // 设置数组中的第2个元素为第一次循环要插入的数据
            int insert = arr[i];
            // 如果要插入的元素小于第j个元素，就将第j个元素向后移
            while (j >= 0 && insert < arr[j]) {
                arr[j + 1] = arr[j];
                j --;
            }
            // 直到要插入的元素不小于第j个元素,将insertNote插入到数组中 
            arr[j + 1] = insert;
        }
    }
```

#### 三种算法总结

- 选择排序
- 冒泡排序
- 插入排序

#### 其他排序算法

- 这里的三种排序是最低效的排序算法
  - 思路简单，容易理解和实现
  - 是高效排序算法的基础
  - 高效排序：快速排序、堆排序、希尔排序、桶排序、合并排序、基排序等

#### 查找

查找：是一种在列表中<font color='red'>确定目标所在位置</font>的算法

两种基本查找方法：

- 顺序查找：被查找的列表可以<font color='red'>无序</font>
- 折半查找：被查找的列表是<font color='red'>有序的</font>

**顺序查找**：用于查找无序列表，一般用于查找<font color='red'>较小</font>的或不常用的列表

顺序查找是<font color='red'>从列表起始处</font>开始查找，当找到目标元素或确信查找的目标不在列表中时，查找过程结束

![image-20221209155838088](算法.assets/image-20221209155838088.png)

**折半查找**：当列表中的元素很多时，顺序查找的速度很慢，当列表有序时，可以通过折半查找提高查找速度

折半查找从列表的中间元素来判断，判断出目标在列表的前半部分还是后半部分，如果在前半部分，就不需要再查找后半部分。如果在后半部分，就不需要再查找前半部分，重复这个过程，直到找到目标或目标不在列表中

![image-20221209160438366](算法.assets/image-20221209160438366.png)

#### 子算法

子算法：<font color='red'>结构化编程</font>的原则要求将算法分成几个单元，称为子算法。

每个子算法依次又可以分为更小的子算法

使用子算法的<font color='red'>优点</font>：

- 程序更容易理解
- 子算法可以在主算法中不同地方调用

<font color='red'>选择排序</font>中的子算法:

![image-20221209160704596](算法.assets/image-20221209160704596.png)

#### 递归与迭代

**迭代**（iteration）：重复反馈过程的活动，每一次迭代的结果会作为下一次迭代的初始值。（A重复调用B）。（aka：重复执行一系列运算步骤，从前面的量依次求出后面的量的过程。此过程的每一次结果，都是由对 **前一次所得结果 施行相同的运算步骤** 得到的）

![image-20221209164603704](算法.assets/image-20221209164603704.png)

**递归**（recursion）：递归常被用来描述以自相似方法重复事物的过程，在数学和计算机科学中，指的是在函数定义中使用函数自身的方法。（A调用A）

![image-20221209164620278](算法.assets/image-20221209164620278.png)

![image-20221209164646119](算法.assets/image-20221209164646119.png)

![image-20221209164734391](算法.assets/image-20221209164734391.png)
