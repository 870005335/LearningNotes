# 第三章 数据存储

- 计算机中的5中不同的数据类型
- 不同的数据类型如何以位模式存储在计算机内部
- 整数如何以无符号格式存储在计算机中
- 整数如何以符号加绝对值格式存储在计算机中
- 整数如何以二进制补码格式存储
- 实数如何以浮点格式存储在计算机中
- 文本如何存储在计算机中
- 音频如何存储在计算机中
- 图像如何存储在计算机中
- 视频如何存储在计算机中

## 数据类型

![image-20220726110540496](数据存储.assets/image-20220726110540496.png)

计算机中使用“<font color='red'>多媒体</font>”来定义包含数字、文本、音频、图像、视频的信息

## 计算机内部数据格式

- <font color='red'>位</font>（bit，binary digit缩写）是存储在计算机中的最小单位：0或1，代表设备的某一种状态。

- <font color='red'>位模式</font>（位流）：表示数据的不同类型，多个位组成一个位模式，由16个位组成的位模式，如图：

  ![image-20220726111214799](数据存储.assets/image-20220726111214799.png)

  如果我们需要存储1000个位模式，每个16位，需要16000个开关

- <font color='red'>字节</font>：长度为8的位模式，称为1字节

- 字：指代更长位模式，比如可以表示<font color='red'>1个字 = 2字节</font>  或 <font color='red'>1个字 = 4字节</font> 等等

正如下图所示，属于不同类型的数据可以以同样的模式存储于内存中。

![image-20220726111418379](数据存储.assets/image-20220726111418379.png)

## 存储数字

在存储到计算机内存之前，数字被转换成二进制系统，但是：

1. 如何存储数字的正负符号
2. 如何显示小数点

### 存储整数

整数是完整的数字（即没有小数部分）。例如，134和-125是整数，而134.23和-0.235则不是。整数可以被当作小数点位置固定的数字：小数点固定在最右边。因此，<font color='red'>定点表示法</font>用于存储整数，如下图所示。在这种表示法中，小数点是假定的，但并不存储。

![image-20220726111907136](数据存储.assets/image-20220726111907136.png)

<font color='red'>整数通常使用定点表示法存储字内存中。</font>

#### 无符号表示法

**无符号整数**是只包括零和整数的非负整数。它的范围介于0到无穷大之间。然而，由于计算机不可能表示这个范围的所有整数，通常，计算机都定义了一个常量，称为***最大无符号整数***，它的值是（2<sup>n</sup>-1）。这里的n就是计算机中分配用于表示无符号整数的二进制位数。

存储无符号整数：

输入设备存储无符号整数使用以下步骤：

1. 首先将整数变成二进制数。
2. 如果二进制数不足n位，则在二进制数的左边补0，使它的总位数为n位。如果位数大于n，该整数无法存储。导致***溢出***的情况发生，我们后面要讨论。

#### 无符号表示法示例

例1：将7存储在8位存储单元中，使用无符号表示法。

解	首先将数字转换为二进制数(111)<sub>2</sub>。加5个0使之总的位数变成8位，即(00000111)<sub>2</sub>。再将该整数保存在存储单元中。

注意：右下角的2用于强调该整数是二进制的，并不存储在计算机中。

![image-20220726113155252](数据存储.assets/image-20220726113155252.png)

例2：将258存储在16位存储单元中。

解	首先把数字转换为二进制数(100000010)<sub>2</sub>。加7个0使总位数变成16位，记得到(000000100000010)<sub>2</sub>。再将该整数存储在存储单元中。

![image-20220726113459871](数据存储.assets/image-20220726113459871.png)

#### 译解无符号整数

输出设备译解内存中位模式的位串并转换为一个十进制的无符号整数。

例：当译解作为无符号整数保存在内存中的位串00101011时，从输出设备返回什么？

解	使用第2章的解题过程，二进制整数转换为十进制无符号整数43。

#### 溢出

因为存储单元位的数量限制，<font color='red'>可以表达的整数范围是有限的</font>，在n位存储单元中，可以存储的无符号整数的范围仅为（0～2<sup>n</sup>-1）。

![image-20220726114508540](数据存储.assets/image-20220726114508540.png)

#### 无符号整数的应用

无符号整数表示法可以提高存储效率，因为不必存储整数的符号。这就意味着所有分配的存储位单元都可以用来存储数字。只要用不到负整数，都可以用无符号整数表示法。具体情况如下：

- **计数**：当我们计数时，不需要负数。可以从1（有时0）开始增长。
- **寻址**：有些计算机语言，在一个存储单元中存储了另一个存储单元的地址。地址都是从0（存储器的第一个字节）开始到整个存储器的总字节数的正数。在这里同样也是不需要用到负数。因此无符号整数可以轻松地完成这个工作。
- **存储其它数据类型**：我们后面将谈到的其它数据类型（文本、图像、音频和视频）是以位模式存储的，可以翻译为无符号整数。

#### 符号加绝对值表示法

用于无符号整数的有效位置（0～2<sup>n</sup>-1）被分成两个相等的子范围，前部分表示整数，后部分表示负数

![image-20220726134639299](数据存储.assets/image-20220726134639299.png)

- 该系统中有两个0：正0(0000),负0(1000)
- 符号加绝对值存储一个整数时，需要用一个二进制位表示符合（0表示正，1表示负）
- 在最左位用于符号定义（0表示正，1表示负）

#### 符号加绝对值表示法示例

例1：用符号加绝对值表示法将+28存储在8位存储单元中。

解	先把该整数转换成7位的二进制数。最左边位置0，即存储为8位数。

![image-20220726135111474](数据存储.assets/image-20220726135111474.png)

例2：用符号加绝对值表示法将-28存储在8位存储单元中。

解	先把该整数转换成7位的二进制数。最左边位置1，即存储为8位数。

![image-20220726135159439](数据存储.assets/image-20220726135159439.png)

例3：将用符号加绝对值表示法存储的01001101复原成整数。

解	因为最左位是0，符号为负。其余位（1001101）转换成十进制数为77。加上符号为+77。



例4：将用符号加绝对值表示法存储的10100001复原成整数。

解	因为最左位是1，符号为负。其余位（0100001）转换成十进制数为33。加上符号为-33。

#### 符号加绝对值表示法溢出

正负溢出两种情况：![image-20220726135757236](数据存储.assets/image-20220726135757236.png)

#### 二进制补码表示法

几乎所有的计算机都使用<font color='red'>二进制补码</font>表示法来存储n位存储单元中<font color='red'>有符号整数</font>

![image-20220726140044570](数据存储.assets/image-20220726140044570.png)

在二进制补码表示法中，最左位决定符号，如果是0，<font color='red'>该整数</font>为正，如果是1，<font color='red'>该整数</font>为负

<font color='red'>反码</font>

简单反转各个位，即把0变成1，把1变成0，该运算不区分正负数。

例1：下面显示我们如何取整数00110110的反码。

![image-20220726141431911](数据存储.assets/image-20220726141431911.png)

例2：下面显示我们如果进行两次反码运算，就可以得到原先的整数

![image-20220726141530988](数据存储.assets/image-20220726141530988.png)

<font color='red'>补码（有两种运算方式）</font>

1. 首先，从右边位复制，直到有1被复制，接着反转其余位。
2. 先取整数的反码，再加1（<font color='red'>取反加1</font>）

例1：下面显示我们如何取整数00110100的补码。

![image-20220726142747682](数据存储.assets/image-20220726142747682.png)

例2：下面显示我们如果进行两次补码运算，就可以得到原先的整数。

![image-20220726142920100](数据存储.assets/image-20220726142920100.png)

<font color='red'>以二进制补码格式存储整数</font>

以二进制补码格式存储整数，计算机遵循以下步骤：

- 将整数变为n位的二进制数
- 如果整数是整数或0，以其原样存储；如果是负数，计算机取其补码存储。

<font color='red'>从二进制补码格式还原整数</font>

从二进制补码格式还原整数，计算机遵循以下步骤：

- 如果最左位是1，计算机取其补码。如果最左位是0，计算机不做操作
- 计算机将该整数转换为十进制



例1：用二进制补码表示法将整数28存储在8位存储单元中。

解	该整数是正数（无符号意味正数），因此把该整数从十进制转换成二进制后不再需要其他操作。注意：3个多余的0加到该整数的左边使其成为8位

![image-20220726144553040](数据存储.assets/image-20220726144553040.png)

例2：用二进制补码表示法将整数-28存储在8位存储单元中。

解	该整数是负数，因此在转换成二进制后计算机对其进行补码运算。

![image-20220726151334677](数据存储.assets/image-20220726151334677.png)

例3：将用二进制补码表示法存储在8位存储单元中的00001101还原成整数。

解	最左位是0，因此符号为正。该整数需要转换为十进制并加上符号即可。

![image-20220726151648361](数据存储.assets/image-20220726151648361.png)

例4：将用二进制补码表示法存储在8位存储单元中的11000110还原成整数。

解	最左位是1，因此符号为负。在整数转换为十进制前进行补码运算。

![image-20220726151822451](数据存储.assets/image-20220726151822451.png)

#### 二进制补码表示法溢出

![image-20220726152311516](数据存储.assets/image-20220726152311516.png)

### 存储实数

#### 定点表示法

实数是带有整数部分和小数部分的数字

在十进制系统中，假定我们用一种小数点右边两个码数，左边14个码数，总共16个码数的定点表示法。那么如果试图表示十进制数1.00234，该系统的实数精度就会受损。该系统把这个数字存储为1.00。

在十进制系，假定用一种小数点右边6个码数，左边10个码数，总共16个码数的定点表示法。那么如果试图表示十进制数236 154 302 345.00，该系统实数精度就会受损。该系统就会把这个数字存储为6 154 302 345.00。整数部分比实际小了很多。

<font color='red'>带有很大的整数部分或很小的小数部分的实数不应该用定点表示法存储</font>

#### 浮点表示法

用于维持正确度或精度的解决方法是使用**浮点表示法**。该表示法允许小数点浮动：我们可以在小数点的左右有不同数量的数码。使用这种方法极大地增加了可存储的实数范围：带有很大的整数部分或很小的小数部分的实数可以存储在内存中了。在浮点表示法中，无论十进制还是二进制，一个数字都由3部分组成，如图

![image-20220726154036954](数据存储.assets/image-20220726154036954.png)

第一部分是符号，可正可负。第二部分显示小数点应该左右移动构成实际数字的位移量。第三部分是小数点位置固定的定点表示法

浮点表示法在科学中用于表示很小或很大的十进制数。在称作***科学计数法***的表示法中，定点部分在小数点左边只有1个数码而且位移量是10的幂次。

例1：下面演示科学计数法（浮点表示法）表示的十进制数7 425 000 000 000 000 000 000.00。

解	![image-20220726161822407](数据存储.assets/image-20220726161822407.png)

例2：用科学计数法表示数字-0.000 000 000 000 03 2。

解	使用前例同样的方法，将小数点移到数码2之后，如下所示：

![	](数据存储.assets/image-20220726164013149.png)

![image-20220726222937913](数据存储.assets/image-20220726222937913.png)

#### 规范化

为了使表示法的固定部分统一，科学计数法（用于十进制）和浮点数表示法（用于二进制）都在小数点左边使用了唯一的非零数码，这称为规范化。十进制系统中的数码可能是1~9，而二进制系统中该数码是1。在下面，d是非零数码，x是一个数码，y是0或1。

![image-20220726224006287](数据存储.assets/image-20220726224006287.png)

#### 符号、指数和尾数

在一个二进制数规范化后，我们只存储了一个数的三部分信息：符号、指数和尾数（小数点右边的位）。例如，+1000111.0101规范化后变成为：

![image-20220726224219930](数据存储.assets/image-20220726224219930.png)

**注意：小数点和定点部分左边的位1并没有存储，它们是隐含的**

#### 余码系统

尾数可以作为无符号数存储。指数（即显示多少位小数点应该左移或右移的幂次）是有符号的数。尽管这可以用二进制补码表示法来存储，但被一种称为余码系统的新的表示法取而代之。在该余码系统中，正的和负的整数都可以作为无符号数存储。为了表示正的或负的整数，一个正整数（**称为一个偏移量**）加到每个数字中，将它们统一移到非负的一边。这个偏移量的值是2<sup>m-1</sup>，m是内存单元存储指数的大小。