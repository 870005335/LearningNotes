# 对象的实例化、内存布局与访问定位

## 1-对象的实例化

### 大厂面试题

![image-20230302180244306](对象的实例化、内存布局与访问定位.assets/image-20230302180244306.png)

### 对象实例化

![image-20230302180314341](对象的实例化、内存布局与访问定位.assets/image-20230302180314341.png)

### 对象创建方式

- new：最常见的方式、单例类中调用getInstance的静态类方法，XXXFactory的静态方法
- Class的newInstance方法：在JDK9里面被标记为过时的方法，因为只能调用空参构造器
- Constructor的newInstance(XXX)：反射的方式，可以调用空参的，或者带参的构造器
- 使用clone()：不调用任何的构造器，要求当前的类需要实现Cloneable接口中的clone接口
- 使用序列化：序列化一般用于Socket的网络传输
- 第三方库 Objenesis

### 创建对象的步骤

<font color='blue'>前面所述的是从字节码角度看待对象的创建过程，现在从执行步骤的角度来分析：</font>

![image-20230302181257685](对象的实例化、内存布局与访问定位.assets/image-20230302181257685.png)

#### 判断对象对应的类是否加载、链接、初始化

虚拟机遇到一条new指令，首先去检查这个指令的参数是否能够在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化（即判断类元信息是否存在）。如果没有，使用当前类加载器以ClassLoader + 包名 + 类名为key进行查找对应的.class文件，如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class对象。

#### 为对象分配内存